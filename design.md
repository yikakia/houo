仙子编码器

# 编码与解码

码表：['哦', '齁', '♥', '啊', '呜', '嗯', '唔']

## 编码

对于输入的字符串，将其转化为utf-8字节序列，二进制数对照码表进行转译，编码逻辑类似base7

编码后的字符串增加前缀 仙子曰： 作为特征字符串

## 解码

去掉前缀 仙子曰： 后，将剩余字符对应码表转译为字节数组，再按照 utf8 解码为字符串

# TODO

协议：将输入的字符串看作字节序列，还需要引入额外的头部用于未来版本更新。具体设计如下

“仙子编码”协议设计总览
本设计旨在提供一种可扩展、版本自描述的字符串编码方案。它将任意字符串转换为一种以特定七个字符为码表的Base7编码格式，同时在编码流中内置了协议头部，以支持未来的功能扩展（如压缩、加密）并确保向后兼容性。

一、 基础定义
特征前缀: 仙子曰：

用于唯一标识此编码格式的字符串。

码表 (Base7): ['哦', '齁', '♥', '啊', '呜', '嗯', '唔']

用于将二进制字节流与可见字符进行转译。

二、 整体结构
编码后的最终字符串由两部分构成：

`[特征前缀]` + `[Base7编码后的字节流]`

核心在于内部的字节流结构，它被设计为包含一个协议头部和一个数据载荷。

三、 核心字节流构造
在进行Base7编码之前，程序需要先构造一个字节数组。该数组的结构如下：

`[协议头部 (Header)]` + `[载荷 (Payload)]`

协议头部 (Protocol Header) 设计
协议头部是本方案实现可扩展性的关键。它由三个连续的部分组成：

`[控制字节]` + `[元信息长度]` + `[元信息体]`

1. 编码方案简述
A. 控制字节 (Control Byte) - 1字节

这是头部的第一个字节，也是整个协议的“指挥中心”。它的8个比特位被分配给不同的功能开关。

Bit 7 (MSB)	Bit 6        Bit 5-0
版本标志	 压缩标志      保留位	    
1=新协议     1 启用压缩  (未来使用 可能用一位标志启用加密)	 
0=旧协议	 0 无压缩

版本标志 (Bit 7): 协议的核心。1表示存在头部结构；0表示为旧版纯数据格式，用于向后兼容。

B. 元信息长度 (Metadata Length) - 1至N字节

紧跟在控制字节之后，用于描述下一部分「元信息体」的字节长度。为了使其自身长度也可扩展，这里采用 Varint (可变长度整数) 编码方案。

编码规则: 每个字节的最高位(MSB)作为“延续标志位”。

若MSB为 1，表示长度数字未结束，后面还有字节。

若MSB为 0，表示这是描述长度的最后一个字节。

每个字节的低7位用于存储长度数据。

C. 元信息体 (Metadata Body) - 0至N字节

这里存放着由「元信息长度」字段所描述的、可变长度的实际元数据。

用途: 存储加密所需的初始化向量(IV)、时间戳、数据签名等。如果不需要，此部分长度可以为0。

编码流程总结：

对原始字符串进行预处理（如压缩、加密），得到载荷。

准备元信息体（如压缩算法的id）。

压缩时进行长度判断，如果转码后的数据长度大于 100 字节，则启用压缩

元信息体中，如果控制字节中启用了压缩，则元信息体中的第一个字节为压缩算法的id

0x01 = Deflate
0x02 = Gzip

获取元信息体的字节长度，并使用 Varint 对该长度进行编码。

根据所用的处理方法（压缩、加密等），构建控制字节。

按顺序组合最终字节流：[控制字节] + [Varint编码的长度] + [元信息体] + [载荷]。

将这个完整的字节流进行 Base7 编码。

在最前面加上特征前缀 仙子曰：。

2. 解码方案简述
解码是编码的逆过程，关键在于正确解析头部信息。

解码流程总结：

校验并移除前缀 仙子曰：。

对剩余的仙子字符进行 Base7 解码，得到原始的字节流。

读取第一个字节，即控制字节。

检查其最高位 (MSB)：

如果为 0，则判定为旧版协议。整个字节流都是纯UTF-8数据，直接进行解码。

如果为 1，则判定为新版协议，继续执行以下步骤。

从第二个字节开始，解码 Varint，读取出「元信息长度」。

根据解码出的长度，读取后续相应字节数的元信息体。字节流中余下的部分即为载荷。

逆向编码过程，先解压，再将最终处理得到的字节数组使用 UTF-8 解码为原始字符串。